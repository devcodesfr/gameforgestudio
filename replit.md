# GameForge Studio

## Overview

GameForge Studio is a comprehensive game development platform that provides developers and gamers with tools for project management, asset browsing, team collaboration, analytics, and community engagement. The platform features a dual-experience design: a developer-focused interface with project management and publishing tools, and a consumer-focused interface for browsing and playing games.

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Frontend Architecture

**Framework & Build System:**
- React 18 with TypeScript for type-safe component development
- Vite as the build tool, chosen for fast HMR (Hot Module Replacement) and optimized production builds
- Client-side routing with Wouter for lightweight navigation without full page reloads

**Design System:**
- Tailwind CSS for utility-first styling with custom CSS variables for theming
- Radix UI primitives providing accessible, unstyled components as building blocks
- shadcn/ui components built on top of Radix for consistent, customizable UI elements
- Custom design system following modern developer tool aesthetics (inspired by VS Code, Linear, GitHub)
- Dual theme support: darker theme with vibrant purple for developers, lighter theme for regular users
- Typography: Inter font family for UI, JetBrains Mono for code display

**State Management:**
- TanStack Query (React Query) for server state management, caching, and automatic refetching
- No global client state library - leverages React Query's built-in cache and React's local state
- Custom hooks pattern for encapsulating data fetching logic (e.g., `use-projects.ts`, `use-cart.ts`)

**Component Organization:**
- Atomic design approach with shared UI components in `components/ui/`
- Feature-specific components and hooks organized by domain
- Page components serve as composition layer combining shared components

### Backend Architecture

**Runtime & Framework:**
- Node.js with Express.js for the HTTP server
- TypeScript throughout for full-stack type safety
- ESM (ECMAScript Modules) for modern module system

**API Design:**
- RESTful API structure with resource-based endpoints (`/api/projects`, `/api/cart`, etc.)
- Middleware-based request processing for logging and session management
- Input validation using Zod schemas shared between client and server
- Consistent error handling with appropriate HTTP status codes

**Session Management:**
- Express sessions with `connect-pg-simple` for PostgreSQL-backed session storage
- Session data includes `userId` for authentication state
- Configurable cookie settings for development vs. production environments

### Data Storage Solutions

**Database:**
- PostgreSQL as the primary relational database
- Neon Database serverless PostgreSQL for cloud deployment
- Drizzle ORM for type-safe database operations and query building
- Drizzle Kit for schema migrations and database management

**Schema Design Philosophy:**
- Single source of truth: schemas defined in `shared/schema.ts` using Drizzle's table definitions
- Zod schemas generated from Drizzle schemas for runtime validation
- TypeScript types inferred from Drizzle schemas for compile-time safety
- UUID primary keys generated by PostgreSQL (`gen_random_uuid()`)

**Core Tables:**
- `users`: Authentication, profiles, roles (developer/regular), settings, availability status
- `projects`: Game projects with metadata, status tracking, team collaboration, version control
- `metrics`: User-specific analytics and dashboard metrics
- `assets`: Individual purchasable items (3D models, textures, scripts, etc.)
- `assetBundles`: Collections of assets sold together at discounted prices
- `cartItems`: Shopping cart management with quantity tracking
- `purchases`: Transaction history linking users to purchased assets/bundles
- `gameLibrary`: User's game collection with play statistics and metadata
- `chats`: Team communication channels
- `chatMembers`: Many-to-many relationship for chat participants
- `messages`: Chat message history with timestamps

**Dual Storage Strategy:**
- Production: PostgreSQL via Neon with connection pooling
- Development fallback: In-memory storage implementing the same `IStorage` interface
- Storage abstraction layer (`server/storage.ts`) allows swapping implementations transparently

### Authentication & Authorization

**Authentication Mechanism:**
- Session-based authentication (not JWT) for simplicity and server-side control
- Bcrypt password hashing with 12 salt rounds for security
- Flexible login supporting both username and email as identifiers
- Session stored in PostgreSQL for persistence across server restarts

**Authorization:**
- Role-based access control with two primary roles: `developer` and `regular`
- Developers get access to project management, game engines, asset store, distribution, and analytics
- Regular users get a consumer-focused experience with store, library, and community features
- Navigation items filtered by user role
- Theme dynamically applied based on user role (developer = dark purple, regular = lighter)

**Security Measures:**
- Password requirements enforced via Zod validation (minimum 6 characters)
- HTTP-only cookies prevent XSS attacks from accessing session tokens
- Protected route middleware redirects unauthenticated users to login
- Input validation on all authentication endpoints

### External Dependencies

**Database Services:**
- Neon Database: Serverless PostgreSQL hosting with automatic scaling
- `@neondatabase/serverless`: Driver for connecting to Neon with WebSocket support

**UI Component Libraries:**
- Radix UI: Collection of 25+ accessible component primitives (dialog, dropdown, toast, etc.)
- Provides keyboard navigation, focus management, and ARIA attributes out of the box

**Form Management:**
- React Hook Form: Performant form state management with minimal re-renders
- `@hookform/resolvers`: Integrates Zod schemas for form validation
- Chosen for excellent TypeScript support and reduced boilerplate

**Styling & Utilities:**
- Tailwind CSS: Utility-first CSS framework with custom configuration
- `class-variance-authority`: Type-safe variant management for component styles
- `clsx` + `tailwind-merge`: Utility for conditionally combining Tailwind classes

**Development Tools:**
- Replit-specific plugins for error overlay, cartographer (dependency visualization), and dev banner
- Vite plugins for React Fast Refresh and development experience

**Third-Party Integrations:**
- Google Fonts CDN: Inter and JetBrains Mono font families
- Font Awesome (referenced in design guidelines): Icon library for additional iconography
- Lucide React: Modern icon library with tree-shakeable imports

**Asset Management:**
- Static assets served from `attached_assets/` directory
- Vite alias configuration for easy asset imports throughout the application